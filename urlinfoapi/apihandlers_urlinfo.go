package urlinfoapi

import (
	"encoding/json"
	"log"
	"malware_url_detection/db"
	"malware_url_detection/models"
	"malware_url_detection/util"
	"net/http"
	"net/url"
	"strings"

	"github.com/gorilla/mux"
)

const (
	FAILURE = "FAILURE" // look up failure. Not a malware url.
	SUCCESS = "SUCCESS" // look up success. This is a malware url.
)

// getURLInfo returns the malware url by a given host and port.
func getURLInfo(w http.ResponseWriter, r *http.Request) {
	var apiResp swagger.ApiResp
	vars := mux.Vars(r)
	hostname_and_port, ok := vars["hostname_and_port"]
	if !ok {
		log.Printf("hostname is not provided: %v", ok)
		util.Errorf(w, http.StatusBadRequest, "hostname is not provided: %v", ok)
		return
	}
	path_and_query, ok := vars["original_path_and_query_string"]
	if !ok {
		log.Printf("path is not provided: %v", ok)
		util.Errorf(w, http.StatusBadRequest, "path is not provided: %v", ok)
		return
	}
	query := hostname_and_port + "/" + path_and_query
	query_with_protocol := query
	// If the protocol is not specified in query, then default to using http.
	if !strings.Contains(query_with_protocol, "://") {
		query_with_protocol = "http://" + query_with_protocol
	}

	_, err := url.Parse(query_with_protocol)
	if err != nil {
		log.Println("Not a valid url provided")
		util.Errorf(w, http.StatusBadRequest, "could not parse the given url: %v", err)
		return
	}
	// Check whether this url is malware url or not
	urlInfo, err := db.DB.GetUrl(query)
	if err != nil {
		log.Printf("This url is not a malware url: %s", query)
		apiResp.Status = FAILURE
		apiResp.Code = 204
		apiResp.Message = "This url is not present in the list of malware urls"
		if err := json.NewEncoder(w).Encode(&apiResp); err != nil {
			log.Printf("Could not encode the API response into a JSON format: %v", err)
			util.Errorf(w, http.StatusInternalServerError, "Could not encode the ApI Response into the JSON format: %v", err)
			return
		}
	} else {
		log.Printf("This is a malware url: %s", urlInfo.URL)
		apiResp.Status = SUCCESS
		apiResp.Code = 200
		apiResp.Message = "This url is a malware url"
		if err := json.NewEncoder(w).Encode(&apiResp); err != nil {
			log.Printf("Could not encode the API response into a JSON format: %v", err)
			util.Errorf(w, http.StatusInternalServerError, "Could not encode the ApI Response into the JSON format: %v", err)
			return
		}
	}
}

// updateURLInfo updates the url in the database. url has to be passed in the body.
func updateURLInfo(w http.ResponseWriter, r *http.Request) {
	var urlInputInfo swagger.SetUrl
	var apiResp swagger.ApiResp
	if err := json.NewDecoder(r.Body).Decode(&urlInputInfo); err != nil {
		if _, ok := err.(*json.SyntaxError); ok {
			log.Printf("Body is not valid JSON: %v", err)
			util.Errorf(w, http.StatusBadRequest, "Body was not valid JSON: %v", err)
			return
		}
		log.Printf("Could not get body: %v", err)
		util.Errorf(w, http.StatusInternalServerError, "Could not get body: %v", err)
		return
	}
	var urlOutputInfo db.UrlInfo
	urlOutputInfo.URL = urlInputInfo.URL
	err := db.DB.UpdateUrl(&urlOutputInfo)
	if err != nil {
		log.Printf("Could not update the database: %v", err)
		util.Errorf(w, http.StatusInternalServerError, "Could not update the database: %v", err)
		return
	}
	apiResp.Status = SUCCESS
	apiResp.Code = 200
	apiResp.Message = "Updated the url into database successfully"
	if err := json.NewEncoder(w).Encode(&apiResp); err != nil {
		log.Printf("Could not encode the resp into the JSON format: %v", err)
		util.Errorf(w, http.StatusInternalServerError, "Could not encode the resp into the JSON format: %v", err)
		return
	}
	log.Printf("Successfully updated the url in the database: %s", urlOutputInfo.URL)

}
